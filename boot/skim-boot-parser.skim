(define-library
  (skim compiler parser)
  (export parse)
  (define (parse str)

;; NEW parser state

  (define (make-parser-state)
    (define parser-state (make-hash-table))
    (hash-table-set! parser-state "stream" "")
    (hash-table-set! parser-state "pos" 0)
    (hash-table-set! parser-state "needs-input" #f)
    parser-state)
  (define (stream) (hash-table-ref $PS "stream"))
  (define (stream-set! v) (hash-table-set! $PS "stream" v))
  (define (pos) (hash-table-ref $PS "pos"))
  (define (pos-set! v) (hash-table-set! $PS "pos" v))
  (define (needs-input) (hash-table-ref $PS "needs-input"))
  (define (needs-input-set! v) (hash-table-set! $PS "needs-input" v))

  (define $PS (make-parser-state))

  (define (peek)
    (if (= (string-length (stream)) (pos))
        ""
        (string-ref (stream) (pos))))

  (define (use)
    (define ret (peek))
    (if (string=? ret "")
        ret
        (begin (pos-set! (+ 1 (pos)))
               ret)))

  (define (done-parsing) (string=? (peek) ""))

  (define (until rx)
    (do ((ret "" ret))
      ((regex-test rx (peek))
       ret)
      (set! ret (string-append ret (use)))))

  (define (get-ws) (until @"^(\S|$)"))

  (define (get-regex)
    (define ret "")
    (define save-pos (pos))
    (define done #f)
    (use)
    (unless (string=? (peek) "\"") (raise "error: meh"))
    (use)
    (define (loop)
      (set! ret (string-append ret (until @"^(\\|\"|$)")))
      (define next-char (peek))
      (when (string=? next-char "")
        ((post-set!) save-pos)
        (need-input-set! #t)
        (set! done #t))
      (when (string=? next-char "\"")
        (use)
        (set! done #t))
      (when (string=? next-char "\\")
        (use)
        (set! next-char (peek))
        (if (string=? next-char "\"")
            (begin (use) (set! ret (string-append ret "\"")))
            (begin
              (set! ret (string-append ret "\\"))
              (set! ret (string-append ret (use))))))

      (if done (make-RegExp ret) (loop)))
    (loop))

  (define (get-string) (define ret "")
    (define save-pos (pos))
    (define done #f)
    (use)
    (define (loop)
      (set! ret (string-append ret (until @"^(\\|\"|$)")))
      (define next-char (peek))
      (when (string=? next-char "")
        (pos-set! save-pos)
        (need-input-set! #t)
        (set! done #t))
      (when (string=? next-char "\"")
        (use)
        (set! done #t))
      (when (string=? next-char "\\")
        (use)
        (set! next-char (peek))
        (case next-char
          (("\"") (begin (use) (set! ret (string-append ret "\\\""))))
          (("n")  (begin (use) (set! ret (string-append ret "\\n"))))
          (("r")  (begin (use) (set! ret (string-append ret "\\r"))))
          (("t")  (begin (use) (set! ret (string-append ret "\\t"))))
          (("f")  (begin (use) (set! ret (string-append ret "\\f"))))
          (("b")  (begin (use) (set! ret (string-append ret "\\b"))))
          (else (begin
                  (set! ret (string-append ret "\\"))
                  (set! ret (string-append ret (use)))))))

      (if done (make-String ret) (loop)))
    (loop))

  (define (get-comment) (define ret (until @"\n")) (use) (list "comment" ret))

  (define (get-hashval)
    (define ret "")
    (use)
    (case (use)
      (("t") (set! ret #t))
      (("f") (set! ret #f))
      (("!") (set! ret (get-comment)))
      (("n") (set! ret nil))
      (else
        (raise (string-append  "unknown hashval: " (peek)))
        nil))
    ret)


  (define (get-atom)
    (define ret "")
    (set! ret (string-append ret (until @"^(\s|\\|\"|'|`|,|\(|\)|$)")))
    (define flt (string->number ret))
    (set! ret (if (nan? flt) ret flt))
    (set! ret (if (string=? ret "") nil ret))
    ret)

  (define (get-atom2)
    (define ret "")
    (define (loop)
      (set! ret (string-append ret (until @"^(\s|\\|\"|'|`|,|\(|\)|$)")))
      (define next-char (peek))
      (if (string=? next-char "\\")
          (begin
            (use)
            (set! ret (string-append ret (use)))
            (loop))
          #f))
    ret)

  (define (get-expr) "" #f)

  (define (get-quote quotestyle)
    (use) ;; get rid of '

    (define ret (list quotestyle (get-expr)))
    (display ret) (newline)
    ret)

  (define (get-list)
    (define save-pos (pos))
    (use)
    (define ret
      (do ((expr (get-expr) (get-expr))
           (retv (list) retv))
        ((nil? expr)
         retv)
        (set! retv (append retv (list expr)))))


    (if (string=? (peek) ")")
        (use)
        (begin
          (pos-set! save-pos)
          (needs-input-set! #t)
          (set! ret (list))))
    ret)

  (define (get-expr)
    (define ret "")
    (needs-input-set! #f)
    (get-ws)
    (define next-char (peek))
    (case next-char
      ((";") (set! ret (get-comment)))
      (("\"") (set! ret (get-string)))
      (("'") (set! ret (get-quote "quote")))
      (("`") (set! ret (get-quote "quasiquote")))
      (("@") (set! ret (get-regex)))
      (("#") (set! ret (get-hashval)))
      (("(") (set! ret (get-list)))
      (else (set! ret (get-atom))))
    (get-ws)
    ret)

  (stream-set! str)


  ;; if we start with #! it means a script (probably)
  (cond ((string=? (peek) "#")
         (until @"\n"))
        (else #t))


  (define exprs (list))

  (do
    ((done #f (done-parsing))
     (expr (get-expr) (get-expr)))
    (done exprs)
    (set! exprs (append exprs (list expr))))

  ;; (define expr (get-expr))
  ;; (define exprs (list expr (list "comment" "HAHA")))

  (when (needs-input)
    (raise "more input needed"))

    exprs)
  )


